## Introduction

This repository contains a [CQL](https://cql.hl7.org/) engine that is based on the [CQL reference implementation](https://github.com/cqframework/clinical_quality_language) and adapted to work with clinical data in databases which conform to the [OMOP Common Data Model](https://www.ohdsi.org/data-standardization/).
Some of the code in this repository has been generated by the [cql-on-omop code generator](https://github.com/umg-minai/cql-on-omop-code-generator).
The contents of the repository is provided under the Apache 2.0 license (see `COPYING` file).

The code in this repository can be compiled into a standalone Java application which connects to an OMOP database supports two interfaces for controlling the CQL evaluation:

* An interactive Read Eval Print Loop (REPL) which reads CQL definitions and expressions from an interactive prompt, evaluates the CQL expressions and displays the results

* Non-interactive batch processing of CQL libraries.
  Results can be handled in different ways.
  Some possibilities are

  * Results are printed to the standard output stream

  * Results are written into one or more CSV files

  * Results are written to the OMOP database

## Usage

Compile the project with

```bash
mvn package
```

Successful compilation produces a standalone application in a file like `target/cql-on-omop-1.0-SNAPSHOT.jar`.

### Interactive REPL

To start the REPL and connect to a database

```bash
CQL_ON_OMOP_DATABASE_PASSWORD=$(GET-PASSWORD) java -jar REPOSITORY-DIRECTORY/target/cql-on-omop-1.0-SNAPSHOT.jar \
  repl -h DATABASE-SERVER-HOST -p DATABASE-SERVER-PORT -u DATABASE-USERNAME -d DATABASE-NAME [-s DATABASE-SCHEMA]
```

The default `DATABASE-SCHEMA` is `cds_cdm`.

Within the REPL, evaluate CQL expressions:

```
[0] [VisitOccurrence]
E1 => List<VisitOccurrence>
  VisitOccurrence{id=30518, concept='Inpatient Visit'}
  VisitOccurrence{id=30519, concept='Inpatient Visit'}
  VisitOccurrence{id=30520, concept='Intensive Care'}
  ...
```

#### Non-CQL Commands

The REPL supports several commands that provide functionality outside the scope of CQL.
Syntactically, these commands start with a `,` to distinguish them from valid CQL expressions.
The most important Non-CQL Commands are

* `,focus CQL-EXPRESSION`

  This command causes `CQL-EXPRESSION` to be evaluated and the resulting value, typically a list of `Person` instances or a single such instance, to be installed as the current context object or as multiple context objects (see below).

* `,reload`

  This command causes all CQL libraries that have been included via `include â€¦` lines to be re-loaded from the filesystem.
  This command is useful for developing and testing CQL libraries with a long-lived REPL session.

#### Current Context and Context Objects

CQL provides the syntax `context CONTEXT-NAME` to select one of the contexts provided by the current data model as the current context.
At the moment, `cql-on-omop` supports the contexts `Unfiltered` and `Patient`.
CQL does not specify how the value (or the values) for a context is determined or installed.
To this end, `cql-on-opop` provides the `,focus` non-CQL command to establish the connection between the current context and its value or values.

For example,

```
,focus [Person]
context Patient
```

results in a state in which each `Person` instance that is produced by the `[Person]` retrieve expression is one value of the `Patient` context.
**Any CQL expression evaluated after the above snippets will be evaluated for each context value, that is each `Person` instance in this case, individually. The results of these individual evaluations will be presented as multiple sections labeled by context value (i.e. `Person` instances) which show the respective computed value**:

```
[1] ,focus [Person]
Focussing on Person{id=0}, Person{id=1}, Person{id=2}, Person{id=3}, Person{id=4}, Person{id=5}, Person{id=6}, Person{id=7}, Person{id=8}, Person{id=9},
[2] context Patient
[3] Count([ConditionOccurrence])
Person{id=5}
E1 => Integer 2
Person{id=3}
E1 => Integer 8
Person{id=6}
E1 => Integer 3
Person{id=8}
E1 => Integer 3
Person{id=9}
E1 => Integer 1
Person{id=7}
E1 => Integer 3
Person{id=1}
E1 => Integer 6
Person{id=0}
E1 => Integer 8
Person{id=2}
E1 => Integer 5
Person{id=4}
E1 => Integer 5
```

### Batch Evaluation

To non-interactively evaluate the definitions in a CQL library, information for the database connection as well as the name of the library has to be specified on the commandline:

```bash
CQL_ON_OMOP_DATABASE_PASSWORD=$(GET-PASSWORD) java -jar REPOSITORY-DIRECTORY/target/cql-on-omop-1.0-SNAPSHOT.jar \
  batch -p DATABASE_SERVER_PORT -u DATABASE_USERNAME -d DATABASE-NAME CQL-LIBRARY-NAME
```

The return value of the process indicates whether the evaluation or any of multiple evaluations failed.
With default `-print-*` options (see below), any errors will be printed in addition to being indicated by the return value.
By default, errors but no evaluation results will be printed to the standard output stream of the process.
Other options for further processing the results computed by CQL expressions include:

* No processing with `--sink noop`, the default

* Writing to the OMOP database with `--sink dbwrite` (final line contains the added options):

  ```bash
  CQL_ON_OMOP_DATABASE_PASSWORD=$(GET-PASSWORD) java -jar REPOSITORY-DIRECTORY/target/cql-on-omop-1.0-SNAPSHOT.jar \
  batch -p DATABASE_SERVER_PORT -u DATABASE_USERNAME -d DATABASE-NAME \
  --sink dbwrite --result-name 'RESULT-REGEX-1' --result-name 'RESULT-REGEX-2' CQL-LIBRARY-NAME
  ```

  This sink writes the objects that are the values of the CQL definitions selected by `RESULT-REGEX-1`, `RESULT-REGEX-2`, etc. into the suitable tables of OMOP database.
  The database tables are chosen based on the types of the objects.
  For example, the commandline options `--sink dbwrite --result-name 'NewPersons' add-persons` will evaluate the definitions in the CQL library `add-persons.cql`, look for a definition `NewPersons` in that library and store the value in the `person` OMOP CDM table, assuming the value of the definition is of type `OMOP.v54.Person` (or some other version) or `List<OMOP.v54.Person>`.
  Id fields will by populated when objects are stored in the database, so CQL libraries should not be concerned with those fields.

  See the file `examples/create-patients.cql` for an example CQL library that works with this sink.

* Writing temporal histograms that are computed from the CQL definitions selected by `RESULT-REGEX-1`, `RESULT-REGEX-2`, etc. into text files.

  ```bash
  CQL_ON_OMOP_DATABASE_PASSWORD=$(GET-PASSWORD) java -jar REPOSITORY-DIRECTORY/target/cql-on-omop-1.0-SNAPSHOT.jar \
  batch -p DATABASE_SERVER_PORT -u DATABASE_USERNAME -d DATABASE-NAME \
  --sink histogram --result-name 'RESULT-REGEX-1' --result-name 'RESULT-REGEX-2' CQL-LIBRARY-NAME
  ```

  The computed temporal histogram for each matching expression definition is written to a text file that is named like the expression definition.
  For example, the commandline options `--sink histogram --result-name 'Population' --result-name 'Intervention' population-and-intervention` will evaluate the definitions in the CQL library `population-and-intervention.cql`, look for the definitions `Population` and `Intervention` in that library, compute two temporal histograms and store the histograms in the files `Population.txt` and `Intervention.txt`.
  Each selected expression has to evaluate to a CQL value of type `List<Date>`.

  See the file `examples/output-histogram.cql` for an example CQL library that works with this sink.

* Plotting temporal histograms as image files for the CQL definitions selected by `RESULT-REGEX-1`, `RESULT-REGEX-2`, etc. into text files.

  ```bash
  CQL_ON_OMOP_DATABASE_PASSWORD=$(GET-PASSWORD) java -jar REPOSITORY-DIRECTORY/target/cql-on-omop-1.0-SNAPSHOT.jar \
  batch -p DATABASE_SERVER_PORT -u DATABASE_USERNAME -d DATABASE-NAME \
  --sink gnuplot --result-name 'RESULT-REGEX-1' --result-name 'RESULT-REGEX-2' CQL-LIBRARY-NAME
  ```

  Like the `histogram` sink explained above but after writing the temporal histograms to text files, call the `gnuplot` program to render the histograms into image files.
  For each selected expression, there will be one text file named like the expression but with the suffix `txt` and one image file named like the expression but with the suffix `png`.

  See the file `examples/output-histogram.cql` for an example CQL library that works with this sink.

* Writing to a CSV file with `--sink csv` (final line contains the added options):

  ```bash
  CQL_ON_OMOP_DATABASE_PASSWORD=$(GET-PASSWORD) java -jar REPOSITORY-DIRECTORY/target/cql-on-omop-1.0-SNAPSHOT.jar \
  batch -p DATABASE_SERVER_PORT -u DATABASE_USERNAME -d DATABASE-NAME \
  --sink csv --result-name 'RESULT-REGEX-1' --result-name 'RESULT-REGEX-2' CQL-LIBRARY-NAME
  ```

  This sink writes the objects that are the values of the CQL definitions selected by `RESULT-REGEX-1`, `RESULT-REGEX-2`, etc. into one or more CSV files.
  The value of each matching expression definition is written to a CSV file that is named like the expression definition.
  For example, the commandline options `--sink csv --result-name 'Population' --result-name 'Intervention' population-and-intervention` will evaluate the definitions in the CQL library `population-and-intervention.cql`, look for the definitions `Population` and `Intervention` in that library and store the values in the files `Population.csv` and `Intervention.csv` respectively.
  This sink has a bit of logic for interpreting differently shaped results as columns and row of CSV files.
  Generally, the following rules apply:

  * The elements of a list turn into rows of the CSV file

  * The elements of a tuple turn into columns of a row

  * A "scalar" value turns into a single column of a row

  * The results for different context values (such a `Person` instance) are turned into sequences of rows and concatenated into an overall sequence of rows

  See the file `examples/output-csv.cql` for an example CQL library that works with this sink.

Sink options are orthogonal to the printing of evaluation results and/or progress indication and/or errors as the evaluation proceeds.
The following options control the printing of such information during evaluation:

* `--print-errors`/`--no-print-errors` (default: errors are printed)

  Print errors that occur during evaluation.
  Errors during evaluation are printed as soon as they are encountered by default.
  In particular, when a CQL library is evaluated repeatedly, for example for each individual patient, the individual evaluations can succeed or fail so that any number of errors may be printed.
  The (UNIX) return value of the process is not affected by this option.

* `--print-results`/`--no-print-results` (default: results are not printed)

  Print each computed result.
  This option is most useful for semi-interactive work and during development and debugging of CQL libraries.
  That said, it is of course possible to additionally select a sink for actual processing of the evaluation results.

* `--print-progress`/`--no-print-progress` (default: progress indication is not printed)

  Print some indication of progress during evaluation.
  This option is most suitable for long-running evaluations in which the processing of results is handled by some sink other than the `noop` sink.
